# 7. Routing avanzado en Angular 20

## 7.1. ConfiguraciÃ³n moderna de rutas con `provideRouter` y Standalone Components

El enrutamiento en Angular siempre ha sido el mecanismo que permite a los usuarios navegar entre diferentes vistas sin recargar la pÃ¡gina. Tradicionalmente, esto se hacÃ­a importando `RouterModule.forRoot()` dentro de un NgModule. Sin embargo, con la llegada de los **Standalone Components** y la API de **Functional Providers**, Angular 20 simplifica y moderniza este proceso.  

### 7.1.1. El cambio de paradigma: de NgModules a `provideRouter`

Antes:  
```ts
@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}
```

Ahora, en Angular 20:  
```ts
import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter } from '@angular/router';
import { AppComponent } from './app.component';
import { routes } from './app.routes';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes)
  ]
});
```

ðŸ‘‰ Ya no necesitamos un `AppRoutingModule`. La configuraciÃ³n es mÃ¡s directa y declarativa.

### 7.1.2. DefiniciÃ³n de rutas con Standalone Components

Cada ruta apunta directamente a un componente standalone.  

Ejemplo en `app.routes.ts`:

```ts
import { Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { UserProfileComponent } from './user-profile/user-profile.component';
import { NotFoundComponent } from './not-found/not-found.component';

export const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'user/:id', component: UserProfileComponent },
  { path: '**', component: NotFoundComponent }
];
```

CaracterÃ­sticas:  
- **Rutas estÃ¡ticas**: `path: ''` â†’ muestra `HomeComponent`.  
- **Rutas dinÃ¡micas**: `path: 'user/:id'` â†’ muestra `UserProfileComponent` con un parÃ¡metro.  
- **Ruta comodÃ­n**: `path: '**'` â†’ captura cualquier URL no definida y muestra `NotFoundComponent`.  

### 7.1.3. Lazy Loading con `loadComponent`

Una de las grandes ventajas del modelo standalone es que podemos cargar componentes bajo demanda, sin necesidad de mÃ³dulos.  

```ts
export const routes: Routes = [
  {
    path: 'settings',
    loadComponent: () =>
      import('./settings/settings.component').then(m => m.SettingsComponent)
  }
];
```

ðŸ‘‰ Esto reduce el tamaÃ±o inicial del bundle y mejora el rendimiento en aplicaciones grandes.

### 7.1.4. IntegraciÃ³n con Functional Providers

El enrutador puede configurarse con **opciones adicionales** usando funciones auxiliares:

```ts
import { provideRouter, withHashLocation } from '@angular/router';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, withHashLocation())
  ]
});
```

- `withHashLocation()` â†’ usa `#/ruta` en lugar de `ruta` (Ãºtil en entornos donde el servidor no soporta rutas limpias).  
- TambiÃ©n existen `withDebugTracing()`, `withPreloading()`, etc., para ajustar el comportamiento del router.  

### 7.1.5. Beneficios del modelo moderno

- **Menos boilerplate**: no mÃ¡s `AppRoutingModule`.  
- **Standalone-first**: cada componente puede ser directamente una ruta.  
- **Lazy loading simplificado**: con `loadComponent` no hacen falta mÃ³dulos intermedios.  
- **ConfiguraciÃ³n declarativa**: `provideRouter` y sus helpers (`withX`) hacen que el cÃ³digo sea mÃ¡s legible y mantenible.  


## 7.2. Lazy loading optimizado con `loadChildren` y rutas dinÃ¡micas

El **lazy loading** (carga diferida) es una tÃ©cnica fundamental en Angular para mejorar el rendimiento: en lugar de cargar toda la aplicaciÃ³n al inicio, solo se cargan los mÃ³dulos o componentes cuando el usuario realmente los necesita. Esto reduce el *bundle* inicial, acelera el arranque y optimiza el uso de recursos.  

En Angular 20, el lazy loading se integra de forma natural con el modelo **standalone** y se potencia con `loadChildren`, que permite cargar mÃ³dulos o componentes bajo demanda, incluso de forma condicional o dinÃ¡mica.

### 7.2.1. Lazy loading clÃ¡sico con `loadChildren`

En versiones anteriores, `loadChildren` se usaba para cargar mÃ³dulos enteros. En Angular 20, sigue siendo vÃ¡lido, pero ahora puede apuntar tanto a **mÃ³dulos** como a **componentes standalone**.

Ejemplo con un mÃ³dulo:

```ts
export const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () =>
      import('./admin/admin.routes').then(m => m.ADMIN_ROUTES)
  }
];
```

En `admin.routes.ts`:

```ts
import { Routes } from '@angular/router';
import { AdminDashboardComponent } from './admin-dashboard.component';

export const ADMIN_ROUTES: Routes = [
  { path: '', component: AdminDashboardComponent }
];
```

ðŸ‘‰ AquÃ­, el mÃ³dulo de administraciÃ³n solo se carga cuando el usuario navega a `/admin`.

### 7.2.2. Lazy loading de componentes standalone

Con Angular moderno, ya no es necesario crear mÃ³dulos intermedios. Podemos cargar directamente un componente standalone:

```ts
export const routes: Routes = [
  {
    path: 'settings',
    loadComponent: () =>
      import('./settings/settings.component').then(m => m.SettingsComponent)
  }
];
```

ðŸ‘‰ Esto simplifica la arquitectura y reduce el *boilerplate*.

### 7.2.3. Rutas dinÃ¡micas con `loadChildren`

En aplicaciones enterprise, a menudo necesitamos que las rutas dependan de **condiciones dinÃ¡micas**:  
- El rol del usuario.  
- Un *feature flag*.  
- El entorno (dev, staging, prod).  

Podemos usar `loadChildren` con factorÃ­as que devuelvan rutas distintas segÃºn la lÃ³gica.

Ejemplo: rutas basadas en rol de usuario

```ts
export const routes: Routes = [
  {
    path: 'dashboard',
    loadChildren: () => {
      const role = localStorage.getItem('role');
      if (role === 'admin') {
        return import('./admin/admin.routes').then(m => m.ADMIN_ROUTES);
      }
      return import('./user/user.routes').then(m => m.USER_ROUTES);
    }
  }
];
```

ðŸ‘‰ AquÃ­, Angular carga dinÃ¡micamente el conjunto de rutas adecuado segÃºn el rol del usuario.

### 7.2.4. OptimizaciÃ³n con `canLoad` y `canMatch`

- **`canLoad`**: evita que un mÃ³dulo se cargue si el usuario no cumple ciertas condiciones (ej. no estÃ¡ autenticado).  
- **`canMatch`**: decide si una ruta debe coincidir o no antes de cargarla, lo que permite mayor flexibilidad.  

Ejemplo con `canLoad`:

```ts
{
  path: 'reports',
  loadChildren: () => import('./reports/reports.routes').then(m => m.REPORTS_ROUTES),
  canLoad: [AuthGuard]
}
```

ðŸ‘‰ Esto asegura que el mÃ³dulo de reportes no se cargue si el usuario no estÃ¡ autenticado.

### 7.2.5. Estrategias de pre-carga combinadas

El lazy loading puede complementarse con **estrategias de pre-carga** (`PreloadAllModules` o estrategias personalizadas) para cargar en segundo plano los mÃ³dulos que probablemente se necesiten pronto, sin afectar el arranque inicial.  

Ejemplo:

```ts
import { provideRouter, withPreloading, PreloadAllModules } from '@angular/router';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, withPreloading(PreloadAllModules))
  ]
});
```

ðŸ‘‰ Esto mejora la experiencia de usuario: la primera navegaciÃ³n a un mÃ³dulo lazy-loaded serÃ¡ instantÃ¡nea.


## 7.3. Estrategias de precarga inteligente y bajo demanda con Signals

La **precarga de rutas** es una tÃ©cnica que permite a Angular cargar en segundo plano mÃ³dulos o componentes que el usuario todavÃ­a no ha visitado, anticipÃ¡ndose a sus acciones. Esto mejora la experiencia de usuario, ya que cuando finalmente navega a esa ruta, el contenido ya estÃ¡ disponible en memoria.  

En Angular clÃ¡sico, la precarga se gestionaba con estrategias como `PreloadAllModules` o estrategias personalizadas basadas en RxJS. En Angular 20, gracias a la introducciÃ³n de **Signals**, podemos implementar **estrategias de precarga mÃ¡s inteligentes, reactivas y contextuales**, que se adaptan dinÃ¡micamente al comportamiento del usuario y a las condiciones de la aplicaciÃ³n.

### 7.3.1. Precarga tradicional vs precarga con Signals

- **Tradicional**:  
  - Se definÃ­a una estrategia global (`PreloadAllModules` o una clase que implementaba `PreloadingStrategy`).  
  - La lÃ³gica dependÃ­a de observables y suscripciones manuales.  
  - Era difÃ­cil adaptar la precarga a condiciones cambiantes en tiempo real.  

- **Con Signals**:  
  - Podemos usar **valores reactivos** que cambian automÃ¡ticamente segÃºn el estado de la aplicaciÃ³n.  
  - La precarga se activa o desactiva en funciÃ³n de seÃ±ales como: rol del usuario, conectividad de red, interacciÃ³n previa, o incluso *feature flags*.  
  - La lÃ³gica es mÃ¡s declarativa y predecible, sin necesidad de gestionar suscripciones manuales.  

### 7.3.2. Ejemplo bÃ¡sico: precarga condicional con Signals

Supongamos que queremos precargar el mÃ³dulo de **reportes** solo si el usuario tiene rol de administrador.

```ts
import { signal, effect } from '@angular/core';
import { Router, Route } from '@angular/router';

const isAdmin = signal(false); // valor reactivo que cambia segÃºn login

export function smartPreload(router: Router, routes: Route[]) {
  effect(() => {
    if (isAdmin()) {
      // precargar rutas de admin
      const adminRoute = routes.find(r => r.path === 'admin');
      if (adminRoute?.loadChildren) {
        router.preloader.preloadRoute(adminRoute);
      }
    }
  });
}
```

ðŸ‘‰ AquÃ­, cuando `isAdmin` cambia a `true`, Angular automÃ¡ticamente dispara la precarga del mÃ³dulo de administraciÃ³n. No necesitamos suscripciones manuales ni lÃ³gica imperativa.

### 7.3.3. Precarga bajo demanda (on-demand)

Otra estrategia Ãºtil es la **precarga bajo demanda**, donde el sistema no carga rutas hasta que una seÃ±al especÃ­fica lo indique.  

Ejemplo: precargar el mÃ³dulo de **checkout** solo cuando el usuario aÃ±ade un producto al carrito.

```ts
const hasItemsInCart = signal(false);

export function preloadCheckout(router: Router, routes: Route[]) {
  effect(() => {
    if (hasItemsInCart()) {
      const checkoutRoute = routes.find(r => r.path === 'checkout');
      if (checkoutRoute?.loadChildren) {
        router.preloader.preloadRoute(checkoutRoute);
      }
    }
  });
}
```

ðŸ‘‰ Esto asegura que el flujo de compra sea inmediato cuando el usuario decida pagar, sin retrasos por carga de mÃ³dulos.

### 7.3.4. Precarga predictiva con Signals

Podemos ir mÃ¡s allÃ¡ y usar Signals para implementar **precarga predictiva**:  
- Basada en la navegaciÃ³n previa del usuario.  
- Basada en mÃ©tricas de uso (ej. si el 80% de los usuarios que visitan `/products` luego van a `/checkout`).  
- Basada en condiciones externas (ej. buena conexiÃ³n de red â†’ precargar mÃ¡s rutas; conexiÃ³n lenta â†’ precargar menos).  

Ejemplo simplificado:

```ts
const lastVisited = signal<string | null>(null);

export function predictivePreload(router: Router, routes: Route[]) {
  effect(() => {
    if (lastVisited() === 'products') {
      const checkoutRoute = routes.find(r => r.path === 'checkout');
      if (checkoutRoute?.loadChildren) {
        router.preloader.preloadRoute(checkoutRoute);
      }
    }
  });
}
```

ðŸ‘‰ AquÃ­, si el usuario visita `/products`, automÃ¡ticamente se precarga `/checkout`, anticipando la siguiente acciÃ³n.

### 7.3.5. IntegraciÃ³n con `provideRouter` y estrategias personalizadas

Podemos integrar estas estrategias directamente en la configuraciÃ³n del router:

```ts
import { provideRouter, withPreloading } from '@angular/router';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, withPreloading({
      preload: (route, load) => {
        // lÃ³gica basada en signals
        if (route.data?.['preload'] && isAdmin()) {
          return load();
        }
        return false;
      }
    }))
  ]
});
```

ðŸ‘‰ AquÃ­ combinamos la API moderna de `withPreloading` con Signals para decidir dinÃ¡micamente quÃ© rutas precargar.

### 7.3.6. Beneficios de usar Signals en precarga

- **Reactividad declarativa**: no necesitamos suscripciones manuales ni operadores RxJS complejos.  
- **Adaptabilidad**: la precarga responde automÃ¡ticamente a cambios en el estado de la aplicaciÃ³n.  
- **OptimizaciÃ³n de recursos**: precargamos solo lo necesario, en el momento adecuado.  
- **Mejor experiencia de usuario**: las rutas crÃ­ticas estÃ¡n listas antes de que el usuario las necesite.  


## 7.4. Precarga condicional en entornos de red lenta o mÃ³vil

La **precarga de rutas** es una tÃ©cnica muy Ãºtil para mejorar la experiencia de usuario, pero no siempre conviene aplicarla de manera indiscriminada. En entornos con **redes lentas (2G/3G, conexiones inestables)** o en dispositivos mÃ³viles con **modo ahorro de datos**, precargar mÃ³dulos puede ser contraproducente:  
- Aumenta el consumo de datos.  
- Puede saturar la conexiÃ³n y ralentizar la navegaciÃ³n inicial.  
- Genera frustraciÃ³n en usuarios con planes de datos limitados.  

Por ello, Angular permite definir **estrategias de precarga personalizadas**, y en Angular 20 podemos enriquecerlas con **Signals** y APIs modernas del navegador para detectar el estado de la red.

### 7.4.1. APIs del navegador para detectar condiciones de red

Los navegadores modernos exponen la API **Network Information** (`navigator.connection`), que nos da informaciÃ³n como:  
- `effectiveType`: tipo de red (`4g`, `3g`, `2g`, `slow-2g`).  
- `saveData`: si el usuario activÃ³ el modo ahorro de datos.  
- `downlink`: ancho de banda estimado en Mbps.  

Ejemplo:

```ts
const connection = (navigator as any).connection;
console.log(connection.effectiveType); // "4g", "3g", etc.
console.log(connection.saveData); // true o false
```

ðŸ‘‰ Con esta informaciÃ³n podemos decidir si precargar o no rutas.

### 7.4.2. Estrategia de precarga personalizada

Podemos implementar una clase que extienda `PreloadingStrategy` y condicione la precarga segÃºn el estado de la red.

```ts
import { Injectable } from '@angular/core';
import { Route, PreloadingStrategy } from '@angular/router';
import { Observable, of } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class NetworkAwarePreloadingStrategy implements PreloadingStrategy {
  preload(route: Route, load: () => Observable<any>): Observable<any> {
    const connection = (navigator as any).connection;
    const saveData = connection?.saveData;
    const slowConnection = connection?.effectiveType?.includes('2g') || connection?.effectiveType === '3g';

    if (saveData || slowConnection) {
      // No precargar en redes lentas o con ahorro de datos
      return of(null);
    }

    // Precargar solo si la ruta tiene data.preload = true
    return route.data?.['preload'] ? load() : of(null);
  }
}
```

En la configuraciÃ³n del router:

```ts
import { provideRouter, withPreloading } from '@angular/router';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, withPreloading(NetworkAwarePreloadingStrategy))
  ]
});
```

### 7.4.3. Precarga condicional con Signals

Podemos combinar la API de red con **Signals** para que la estrategia sea reactiva.  

```ts
import { signal, effect } from '@angular/core';

const isSlowNetwork = signal(false);

function detectNetwork() {
  const connection = (navigator as any).connection;
  if (connection) {
    isSlowNetwork.set(connection.saveData || connection.effectiveType.includes('2g') || connection.effectiveType === '3g');
  }
}

detectNetwork();
```

Ahora podemos usar `isSlowNetwork()` dentro de la estrategia de precarga o incluso en componentes para decidir si precargar rutas bajo demanda.

### 7.4.4. Ejemplo prÃ¡ctico: precarga selectiva en mÃ³vil

```ts
export const routes: Routes = [
  {
    path: 'dashboard',
    loadChildren: () => import('./dashboard/dashboard.routes').then(m => m.DASHBOARD_ROUTES),
    data: { preload: true }
  },
  {
    path: 'analytics',
    loadChildren: () => import('./analytics/analytics.routes').then(m => m.ANALYTICS_ROUTES),
    data: { preload: false }
  }
];
```

- En **red rÃ¡pida**: se precarga `dashboard` automÃ¡ticamente.  
- En **red lenta o mÃ³vil con ahorro de datos**: no se precarga nada, y los mÃ³dulos se cargan solo cuando el usuario navega a ellos.  

### 7.4.5. Beneficios de la precarga condicional

- **OptimizaciÃ³n de recursos**: no saturamos la red en condiciones adversas.  
- **Mejor experiencia de usuario**: la aplicaciÃ³n responde mejor en mÃ³viles y redes lentas.  
- **Flexibilidad**: podemos decidir quÃ© rutas precargar segÃºn contexto (rol, dispositivo, red).  
- **Escalabilidad**: fÃ¡cil de extender con Signals, feature flags o mÃ©tricas de uso.  


## 7.5. Functional Guards (`canActivate`, `canMatch`) con `inject()`

Los **guards** en Angular son funciones que actÃºan como **puntos de control** en el enrutador: determinan si un usuario puede acceder a una ruta, si debe redirigirse a otra, o si una ruta debe siquiera considerarse como candidata durante el proceso de *matching*.  

En versiones anteriores, los guards se implementaban como **clases** que implementaban interfaces (`CanActivate`, `CanLoad`, etc.). En Angular moderno, estos **class-based guards estÃ¡n deprecados** en favor de los **Functional Guards**, que son simplemente funciones puras que aprovechan `inject()` para acceder a servicios.  

### 7.5.1. Â¿QuÃ© son los Functional Guards?

- Son **funciones** en lugar de clases.  
- Se definen como constantes tipadas (`CanActivateFn`, `CanMatchFn`, etc.).  
- Usan `inject()` para acceder a servicios como `AuthService`, `Router` o cualquier dependencia registrada en el inyector.  
- Son mÃ¡s concisos, fÃ¡ciles de testear y se integran mejor con el modelo **standalone**.  

### 7.5.2. Ejemplo de `canActivate` funcional

Un caso tÃ­pico: proteger rutas que requieren autenticaciÃ³n.

```ts
import { CanActivateFn, Router } from '@angular/router';
import { inject } from '@angular/core';
import { AuthService } from './auth.service';

export const authGuard: CanActivateFn = (route, state) => {
  const auth = inject(AuthService);
  const router = inject(Router);

  if (auth.isLoggedIn()) {
    return true;
  }
  return router.createUrlTree(['/login']);
};
```

ðŸ‘‰ AquÃ­:  
- Si el usuario estÃ¡ autenticado, devuelve `true` y permite la navegaciÃ³n.  
- Si no lo estÃ¡, devuelve un `UrlTree` para redirigir al login (en lugar de `false`, que bloquearÃ­a sin redirigir).  

Uso en rutas:

```ts
export const routes: Routes = [
  { path: 'dashboard', component: DashboardComponent, canActivate: [authGuard] }
];
```

### 7.5.3. Ejemplo de `canMatch` funcional

`canMatch` decide si una ruta puede **coincidir** durante el proceso de matching. A diferencia de `canActivate`, si devuelve `false`, Angular simplemente prueba con otras rutas en lugar de bloquear la navegaciÃ³n.  

Ejemplo: habilitar una ruta solo si un *feature flag* estÃ¡ activo.

```ts
import { CanMatchFn } from '@angular/router';
import { inject } from '@angular/core';
import { FeatureFlagsService } from './feature-flags.service';

export const analyticsGuard: CanMatchFn = (route, segments) => {
  const flags = inject(FeatureFlagsService);
  return flags.isEnabled('analytics');
};
```

Uso en rutas:

```ts
export const routes: Routes = [
  {
    path: 'analytics',
    loadComponent: () => import('./analytics/analytics.component').then(m => m.AnalyticsComponent),
    canMatch: [analyticsGuard]
  }
];
```

ðŸ‘‰ Si el flag `analytics` estÃ¡ desactivado, Angular ignora esta ruta y sigue evaluando otras coincidencias (por ejemplo, una ruta comodÃ­n `**`).  

### 7.5.4. Diferencias clave entre `canActivate` y `canMatch`

| Guard        | Momento de ejecuciÃ³n | Comportamiento si devuelve `false` | Uso tÃ­pico |
|--------------|----------------------|------------------------------------|------------|
| **canActivate** | Antes de activar una ruta ya seleccionada | Bloquea la navegaciÃ³n o redirige | AutenticaciÃ³n, autorizaciÃ³n |
| **canMatch**   | Durante el proceso de matching de rutas | Ignora la ruta y prueba con otras | Feature flags, A/B testing, rutas condicionales |

### 7.5.5. Ventajas de los Functional Guards con `inject()`

- **Menos cÃ³digo**: no necesitamos clases ni decoradores.  
- **Mayor claridad**: la lÃ³gica estÃ¡ contenida en una funciÃ³n pura.  
- **Testabilidad**: se pueden probar como funciones normales.  
- **IntegraciÃ³n con Signals**: podemos usar Signals dentro de guards para decisiones reactivas (ej. precargar rutas solo si una seÃ±al indica que el usuario estÃ¡ online).  
- **Standalone-friendly**: encajan perfectamente en aplicaciones sin NgModules.  

## 7.6. Functional Resolvers para la carga previa de datos

En muchas aplicaciones, los componentes necesitan datos antes de renderizarse. Si el componente se muestra primero y luego hace la peticiÃ³n, el usuario ve pantallas vacÃ­as o *spinners* que afectan la experiencia. Los **Resolvers** solucionan este problema: permiten que Angular **espere a que los datos estÃ©n listos antes de activar la ruta**.  

En Angular 20, los resolvers han evolucionado hacia un modelo **funcional**, mÃ¡s simple y alineado con el enfoque **standalone** y el uso de `inject()`.

### 7.6.1. Â¿QuÃ© es un Functional Resolver?

- Es una **funciÃ³n** que implementa el tipo `ResolveFn<T>`.  
- Se ejecuta **antes de activar una ruta**.  
- Puede usar `inject()` para acceder a servicios y obtener datos.  
- Devuelve un valor, un `Promise` o un `Observable`.  
- El resultado se inyecta en el componente a travÃ©s de `ActivatedRoute.data`.  

ðŸ‘‰ En lugar de clases que implementan `Resolve<T>`, ahora basta con una funciÃ³n pura.

### 7.6.2. Ejemplo bÃ¡sico de Functional Resolver

Supongamos que queremos precargar los datos de un usuario antes de mostrar su perfil:

```ts
import { ResolveFn } from '@angular/router';
import { inject } from '@angular/core';
import { UserService } from './user.service';

export const userResolver: ResolveFn<any> = (route, state) => {
  const userService = inject(UserService);
  const id = route.paramMap.get('id')!;
  return userService.getUserById(id); // puede devolver Observable o Promise
};
```

ConfiguraciÃ³n en rutas:

```ts
export const routes: Routes = [
  {
    path: 'user/:id',
    component: UserProfileComponent,
    resolve: { user: userResolver }
  }
];
```

En el componente:

```ts
constructor(private route: ActivatedRoute) {
  this.user = this.route.snapshot.data['user'];
}
```

ðŸ‘‰ El componente recibe el usuario ya cargado, sin necesidad de mostrar un *spinner* inicial.

### 7.6.3. Ejemplo avanzado: mÃºltiples resolvers

Podemos usar varios resolvers en la misma ruta:

```ts
export const routes: Routes = [
  {
    path: 'dashboard',
    component: DashboardComponent,
    resolve: {
      stats: statsResolver,
      notifications: notificationsResolver
    }
  }
];
```

ðŸ‘‰ El router esperarÃ¡ a que **todos los resolvers** terminen antes de activar la ruta.

### 7.6.4. Manejo de errores en Functional Resolvers

Si un resolver falla (ej. error en la API), Angular puede:  
- Cancelar la navegaciÃ³n.  
- Redirigir a otra ruta.  
- Devolver un valor alternativo.  

Ejemplo con redirecciÃ³n:

```ts
export const safeUserResolver: ResolveFn<any> = (route, state) => {
  const userService = inject(UserService);
  const router = inject(Router);

  return userService.getUserById(route.paramMap.get('id')!).pipe(
    catchError(() => {
      router.navigate(['/users']);
      return of(null);
    })
  );
};
```

### 7.6.5. Beneficios de los Functional Resolvers

- **Menos boilerplate**: no necesitamos clases ni decoradores.  
- **Mayor claridad**: la lÃ³gica de carga estÃ¡ contenida en funciones puras.  
- **Mejor experiencia de usuario**: los datos estÃ¡n listos antes de renderizar.  
- **IntegraciÃ³n con Signals**: podemos combinar resolvers con Signals para decisiones reactivas (ej. cargar datos solo si un flag estÃ¡ activo).  
- **Standalone-friendly**: encajan perfectamente en aplicaciones sin NgModules.  


## 7.7. CreaciÃ³n y uso de Functional Interceptors en el flujo HTTP

Los **interceptors** en Angular son una especie de *middleware* que se ejecuta en cada peticiÃ³n y respuesta HTTP. Permiten aplicar lÃ³gica transversal sin tener que repetir cÃ³digo en cada servicio o componente. Ejemplos tÃ­picos:  
- AÃ±adir cabeceras de autenticaciÃ³n.  
- Manejar errores de forma centralizada.  
- Implementar *retry* con backoff exponencial.  
- Medir tiempos de respuesta.  
- Mostrar u ocultar un *loading spinner*.  

En Angular 20, los **Functional Interceptors** sustituyen al modelo clÃ¡sico basado en clases (`HttpInterceptor`). Son mÃ¡s simples, predecibles y encajan perfectamente con el enfoque **standalone**.

### 7.7.1. Â¿QuÃ© es un Functional Interceptor?

- Es una **funciÃ³n pura** que implementa el tipo `HttpInterceptorFn`.  
- Recibe dos parÃ¡metros:  
  - `req`: la solicitud saliente (`HttpRequest`).  
  - `next`: una funciÃ³n que representa el siguiente paso en la cadena de interceptores.  
- Devuelve un `Observable<HttpEvent<any>>`, que puede ser transformado antes de llegar al consumidor.  

ðŸ‘‰ A diferencia de los interceptores clÃ¡sicos, no necesitamos crear clases ni usar `@Injectable()`.

### 7.7.2. Ejemplo bÃ¡sico: interceptor de logging

```ts
import { HttpInterceptorFn } from '@angular/common/http';

export const loggingInterceptor: HttpInterceptorFn = (req, next) => {
  console.log('PeticiÃ³n saliente a:', req.url);
  return next(req);
};
```

ðŸ‘‰ Este interceptor simplemente registra en consola cada peticiÃ³n antes de enviarla.

### 7.7.3. Ejemplo prÃ¡ctico: aÃ±adir token de autenticaciÃ³n

```ts
import { HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';
import { AuthService } from './auth.service';

export const authInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const token = authService.getToken();

  if (token) {
    req = req.clone({
      setHeaders: { Authorization: `Bearer ${token}` }
    });
  }

  return next(req);
};
```

ðŸ‘‰ AquÃ­ usamos `inject()` para acceder a `AuthService` y aÃ±adir el token a todas las solicitudes.

### 7.7.4. Manejo centralizado de errores

```ts
import { HttpInterceptorFn } from '@angular/common/http';
import { catchError, throwError } from 'rxjs';

export const errorInterceptor: HttpInterceptorFn = (req, next) => {
  return next(req).pipe(
    catchError(error => {
      console.error('Error HTTP:', error);
      return throwError(() => error);
    })
  );
};
```

ðŸ‘‰ Este interceptor captura errores de red o de servidor y los centraliza en un Ãºnico punto.

### 7.7.5. Registro de interceptores en Angular 20

Los interceptores se configuran al **proveer HttpClient** con `withInterceptors`:

```ts
import { bootstrapApplication } from '@angular/platform-browser';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { AppComponent } from './app.component';
import { loggingInterceptor } from './logging.interceptor';
import { authInterceptor } from './auth.interceptor';
import { errorInterceptor } from './error.interceptor';

bootstrapApplication(AppComponent, {
  providers: [
    provideHttpClient(
      withInterceptors([loggingInterceptor, authInterceptor, errorInterceptor])
    )
  ]
});
```

ðŸ‘‰ El orden importa: se ejecutan en el orden en que se declaran.  

### 7.7.6. Beneficios de los Functional Interceptors

- **Menos boilerplate**: no necesitamos clases ni decoradores.  
- **Mayor claridad**: la lÃ³gica estÃ¡ contenida en funciones puras.  
- **Standalone-friendly**: encajan perfectamente en aplicaciones sin NgModules.  
- **Predecibles**: el orden de ejecuciÃ³n es mÃ¡s fÃ¡cil de razonar.  
- **Testables**: se pueden probar como funciones normales, sin necesidad de Angular TestBed.  


## 7.8. Rutas hijas y segmentaciÃ³n modular en aplicaciones grandes

En aplicaciones enterprise, el enrutamiento no se limita a unas pocas rutas principales. A medida que la aplicaciÃ³n crece, necesitamos **organizar las rutas en jerarquÃ­as** y **segmentar la aplicaciÃ³n en Ã¡reas funcionales**. Angular 20 ofrece un modelo muy flexible para lograrlo, combinando **rutas hijas**, **layouts compartidos**, **lazy loading** y **Standalone Components**.  

### 7.8.1. Â¿QuÃ© son las rutas hijas?

Las **rutas hijas** (o *nested routes*) permiten definir rutas dentro de otras rutas. Esto es Ãºtil cuando una secciÃ³n de la aplicaciÃ³n tiene su propia navegaciÃ³n interna.  

Ejemplo bÃ¡sico:

```ts
export const routes: Routes = [
  {
    path: 'users',
    component: UsersComponent,
    children: [
      { path: 'profile/:id', component: UserProfileComponent },
      { path: 'settings', component: UserSettingsComponent }
    ]
  }
];
```

ðŸ‘‰ AquÃ­, `UsersComponent` actÃºa como **contenedor** y dentro de Ã©l se renderizan las rutas hijas (`profile` y `settings`) en un `<router-outlet>` secundario.

### 7.8.2. El papel de `<router-outlet>`

Para que las rutas hijas funcionen, el **componente padre** debe incluir un `<router-outlet>` en su plantilla. Este elemento es el **punto de anclaje** donde Angular renderiza dinÃ¡micamente el componente hijo correspondiente a la ruta activa.  

Plantilla de `UsersComponent`:

```html
<h2>GestiÃ³n de usuarios</h2>

<nav>
  <a routerLink="profile/1">Perfil Usuario 1</a>
  <a routerLink="settings">ConfiguraciÃ³n</a>
</nav>

<!-- AquÃ­ se renderizan los hijos -->
<router-outlet></router-outlet>
```

ðŸ‘‰ Cuando el usuario navega a `/users/profile/1`, Angular carga `UserProfileComponent` dentro del `<router-outlet>` de `UsersComponent`.

### 7.8.3. SegmentaciÃ³n modular en aplicaciones grandes

En proyectos enterprise, es comÃºn dividir la aplicaciÃ³n en **mÃ³dulos funcionales** o **Ã¡reas de negocio**:  
- `admin` â†’ gestiÃ³n de usuarios, roles, permisos.  
- `shop` â†’ catÃ¡logo, carrito, checkout.  
- `reports` â†’ paneles de estadÃ­sticas.  

Cada Ã¡rea puede tener su propio conjunto de rutas hijas y cargarse de forma diferida (*lazy loading*).  

Ejemplo con `loadChildren`:

```ts
export const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () =>
      import('./admin/admin.routes').then(m => m.ADMIN_ROUTES)
  },
  {
    path: 'shop',
    loadChildren: () =>
      import('./shop/shop.routes').then(m => m.SHOP_ROUTES)
  }
];
```

En `admin.routes.ts`:

```ts
export const ADMIN_ROUTES: Routes = [
  {
    path: '',
    component: AdminLayoutComponent,
    children: [
      { path: 'users', component: UsersComponent },
      { path: 'roles', component: RolesComponent }
    ]
  }
];
```

ðŸ‘‰ AsÃ­, cada mÃ³dulo tiene su propia jerarquÃ­a de rutas y un layout independiente.

### 7.8.4. Layouts compartidos con rutas hijas

Un patrÃ³n muy comÃºn es tener un **layout padre** (con header, sidebar, footer) y dentro de Ã©l un `router-outlet` para las vistas hijas:

```ts
export const routes: Routes = [
  {
    path: '',
    component: MainLayoutComponent,
    children: [
      { path: 'dashboard', component: DashboardComponent },
      { path: 'reports', component: ReportsComponent },
      { path: 'settings', component: SettingsComponent }
    ]
  }
];
```

Plantilla de `MainLayoutComponent`:

```html
<header>Mi aplicaciÃ³n</header>
<aside>MenÃº lateral</aside>

<main>
  <!-- AquÃ­ se cargan las rutas hijas -->
  <router-outlet></router-outlet>
</main>

<footer>Â© 2025</footer>
```

ðŸ‘‰ Todas las rutas hijas (`/dashboard`, `/reports`, `/settings`) comparten el mismo layout.

### 7.8.5. MÃºltiples `router-outlet` (rutas auxiliares)

Angular permite tener mÃ¡s de un `router-outlet` en la misma vista, lo que habilita **rutas auxiliares** o vistas paralelas.

```html
<router-outlet></router-outlet>
<router-outlet name="sidebar"></router-outlet>
```

En la configuraciÃ³n de rutas:

```ts
export const routes: Routes = [
  { path: 'chat', component: ChatComponent, outlet: 'sidebar' }
];
```

ðŸ‘‰ Esto permite cargar `ChatComponent` en el outlet lateral mientras otra ruta principal estÃ¡ activa.

### 7.8.6. Buenas prÃ¡cticas

- **Usar rutas hijas** para secciones con navegaciÃ³n interna (ej. panel de administraciÃ³n).  
- **Dividir la aplicaciÃ³n en mÃ³dulos funcionales** y cargarlos con `loadChildren`.  
- **Incluir siempre `<router-outlet>` en el componente padre** de rutas hijas.  
- **Usar layouts compartidos** para mantener consistencia visual en secciones grandes.  
- **Evitar jerarquÃ­as demasiado profundas**: mejor agrupar rutas en niveles lÃ³gicos.  
- **Documentar la jerarquÃ­a de rutas y outlets** en proyectos enterprise para evitar confusiÃ³n.  


## 7.9. Comparativa entre mÃ³dulos y standalone en el lazy loading

El **lazy loading** (carga diferida) es una tÃ©cnica fundamental en Angular para mejorar el rendimiento: permite cargar partes de la aplicaciÃ³n solo cuando el usuario las necesita, reduciendo el *bundle* inicial y acelerando el arranque.  

En Angular, este patrÃ³n ha evolucionado:  
- En el modelo clÃ¡sico, se implementaba a travÃ©s de **NgModules**.  
- En el modelo moderno (Angular 15+ y consolidado en Angular 20), se puede aplicar directamente sobre **Standalone Components** y configuraciones funcionales.  

### 7.9.1. Lazy loading clÃ¡sico con NgModules

En versiones anteriores, el lazy loading se implementaba cargando **mÃ³dulos de caracterÃ­sticas** completos mediante la propiedad `loadChildren`.  

Ejemplo:

```ts
export const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () =>
      import('./admin/admin.module').then(m => m.AdminModule)
  }
];
```

CaracterÃ­sticas:  
- Se cargaba un **mÃ³dulo entero** (con sus componentes, directivas, pipes y servicios).  
- RequerÃ­a mantener un `AdminModule` y un `AdminRoutingModule`.  
- Era mÃ¡s verboso y generaba *boilerplate*.  
- Encajaba bien en arquitecturas modulares, pero aÃ±adÃ­a complejidad innecesaria en proyectos pequeÃ±os o medianos.  

### 7.9.2. Lazy loading moderno con Standalone Components

Con Angular 20, ya no es necesario crear mÃ³dulos intermedios. Podemos cargar directamente un **Standalone Component** con `loadComponent`, o incluso un conjunto de rutas con `loadChildren`.  

Ejemplo con `loadComponent`:

```ts
export const routes: Routes = [
  {
    path: 'settings',
    loadComponent: () =>
      import('./settings/settings.component').then(m => m.SettingsComponent)
  }
];
```

Ejemplo con `loadChildren` apuntando a rutas standalone:

```ts
export const routes: Routes = [
  {
    path: 'shop',
    loadChildren: () =>
      import('./shop/shop.routes').then(m => m.SHOP_ROUTES)
  }
];
```

CaracterÃ­sticas:  
- Se cargan **componentes standalone** directamente, sin necesidad de mÃ³dulos.  
- Menos *boilerplate* y mÃ¡s claridad.  
- Mejor integraciÃ³n con **Functional Providers** (`provideRouter`, `provideHttpClient`, etc.).  
- Permite segmentar la aplicaciÃ³n en Ã¡reas funcionales sin depender de NgModules.  

### 7.9.3. Diferencias clave

| Aspecto | Lazy loading con NgModules | Lazy loading con Standalone |
|---------|-----------------------------|-----------------------------|
| **Unidad de carga** | MÃ³dulo completo (`FeatureModule`) | Componente standalone o conjunto de rutas |
| **Sintaxis** | `loadChildren: () => import('...').then(m => m.FeatureModule)` | `loadComponent` o `loadChildren` con rutas standalone |
| **Boilerplate** | Requiere `Module` + `RoutingModule` | Solo el componente o archivo de rutas |
| **Flexibilidad** | Buena para arquitecturas modulares clÃ¡sicas | Ideal para apps modernas, mÃ¡s granular |
| **Compatibilidad** | Sigue siendo vÃ¡lido en Angular 20 | Recomendado para nuevos proyectos |

### 7.9.4. Casos de uso

- **NgModules (clÃ¡sico)**  
  - Migraciones de proyectos legacy.  
  - LibrerÃ­as de terceros que aÃºn exponen NgModules.  
  - Equipos acostumbrados a la organizaciÃ³n modular tradicional.  

- **Standalone (moderno)**  
  - Nuevos proyectos en Angular 20.  
  - Aplicaciones que buscan simplicidad y menor tiempo de arranque.  
  - Escenarios donde se quiere cargar **solo un componente** o un conjunto mÃ­nimo de rutas.  


## 7.10. Herramientas de anÃ¡lisis y debugging de rendimiento en el enrutamiento

El enrutamiento es uno de los puntos crÃ­ticos en aplicaciones Angular enterprise:  
- Cada navegaciÃ³n implica **resoluciÃ³n de rutas, guards, resolvers, precarga y renderizado de componentes**.  
- Un mal diseÃ±o puede generar **tiempos de carga elevados**, **navegaciones lentas** o **cargas innecesarias de mÃ³dulos**.  

Por ello, Angular y el ecosistema moderno ofrecen varias herramientas para **analizar, depurar y optimizar el rendimiento del enrutamiento**.

### 7.10.1. Angular DevTools

[Angular DevTools](https://angular.dev/tools/devtools) es la extensiÃ³n oficial para Chrome y Firefox que aÃ±ade un panel especÃ­fico dentro de las DevTools del navegador.  

CaracterÃ­sticas clave:  
- **Inspector de componentes y rutas**: permite visualizar la jerarquÃ­a de componentes y cÃ³mo se relacionan con las rutas activas.  
- **Profiler de rendimiento**: mide el tiempo que tarda Angular en ejecutar detecciÃ³n de cambios y navegaciÃ³n entre rutas.  
- **Debugging de router**: muestra quÃ© rutas se activan, quÃ© guards y resolvers se ejecutan y cuÃ¡nto tardan.  

ðŸ‘‰ Es ideal para detectar cuellos de botella en la navegaciÃ³n y confirmar si la precarga o lazy loading estÃ¡n funcionando como se espera.

### 7.10.2. Tracing y logging del Router

Angular Router expone opciones de **tracing** que permiten registrar en consola cada paso del proceso de enrutamiento.  

Ejemplo de activaciÃ³n:

```ts
import { provideRouter, withDebugTracing } from '@angular/router';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, withDebugTracing())
  ]
});
```

Esto genera logs detallados en la consola del navegador:  
- Coincidencia de rutas.  
- EjecuciÃ³n de guards y resolvers.  
- Carga de mÃ³dulos lazy.  
- Eventos de navegaciÃ³n (`NavigationStart`, `NavigationEnd`, `NavigationError`).  

ðŸ‘‰ Muy Ãºtil en entornos de desarrollo para entender por quÃ© una ruta no se activa o por quÃ© tarda demasiado.

### 7.10.3. MediciÃ³n de tiempos de navegaciÃ³n

Podemos suscribirnos a los eventos del Router para medir tiempos de navegaciÃ³n:

```ts
import { Router, Event, NavigationStart, NavigationEnd } from '@angular/router';

constructor(private router: Router) {
  let start: number;

  this.router.events.subscribe((event: Event) => {
    if (event instanceof NavigationStart) {
      start = performance.now();
    }
    if (event instanceof NavigationEnd) {
      const duration = performance.now() - start;
      console.log(`NavegaciÃ³n completada en ${duration} ms`);
    }
  });
}
```

ðŸ‘‰ Esto permite instrumentar mÃ©tricas personalizadas y enviarlas a herramientas de monitoreo (ej. Grafana, Datadog).

### 7.10.4. Estrategias de profiling con el navegador

AdemÃ¡s de Angular DevTools, podemos usar las **DevTools nativas del navegador**:  
- **Performance tab**: grabar una navegaciÃ³n y analizar cuÃ¡nto tiempo se dedica a scripting, rendering y painting.  
- **Coverage tab**: identificar cÃ³digo no utilizado en mÃ³dulos precargados.  
- **Network tab**: verificar quÃ© bundles se cargan en cada navegaciÃ³n y su tamaÃ±o.  

ðŸ‘‰ Esto ayuda a confirmar si el lazy loading realmente estÃ¡ reduciendo el *bundle* inicial.

### 7.10.5. IntegraciÃ³n con Signals para debugging

En Angular 20, podemos usar **Signals** para exponer el estado del enrutador y depurarlo de forma reactiva.  

Ejemplo: exponer la ruta activa como signal y loguearla en cada cambio:

```ts
import { signal, effect } from '@angular/core';
import { Router, NavigationEnd } from '@angular/router';

const currentRoute = signal<string>('');

constructor(router: Router) {
  router.events.subscribe(event => {
    if (event instanceof NavigationEnd) {
      currentRoute.set(event.urlAfterRedirects);
    }
  });

  effect(() => {
    console.log('Ruta activa:', currentRoute());
  });
}
```

ðŸ‘‰ Esto permite depurar de forma declarativa cÃ³mo cambia la navegaciÃ³n en tiempo real.

### 7.10.6. Buenas prÃ¡cticas de debugging y anÃ¡lisis

- **Activar tracing solo en desarrollo**, nunca en producciÃ³n.  
- **Combinar Angular DevTools con mÃ©tricas personalizadas** para tener una visiÃ³n completa.  
- **Medir tiempos de guards y resolvers**: si tardan demasiado, considerar precarga o caching.  
- **Revisar bundles en Network tab**: confirmar que los mÃ³dulos lazy no se cargan antes de tiempo.  
- **Automatizar mÃ©tricas de navegaciÃ³n** en entornos enterprise para detectar degradaciones de rendimiento.  
